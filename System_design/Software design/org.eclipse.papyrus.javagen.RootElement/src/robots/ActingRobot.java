// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package robots;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Set;
import javax.vecmath.Color3f;
import javax.vecmath.Vector3d;
import RootElement.AttachedDevices;
import RootElement.FileServer;
import mappingEntities.Coordinate;
import mappingEntities.CoordinateRow;
import robots.Robot;

/************************************************************/
/**
 * 
 */
public class ActingRobot extends Robot {
	private boolean foundWall;
	private boolean isFinished;
	private	AttachedDevices attachedDevices;
	private int failedCoordinateSaveCount = 0;
	private int attemptsAtFindingWall = 0;
	private static final int FAILED_SAVE_COORDINATE_THRESHOLD = 100;
	private static final int STOP_THRESHOLD = 200;
	private static final int BOTS_RANGE_THRESHOLD = 100;
	private static final Color3f RED_COLOR = new Color3f(1.0f, 0f, 0f);
	private static final Color3f GREEN_COLOR = new Color3f(0f, 1.0f, 0f);
	private static final double BUMPER_THRESHOLD = 0.2;
	private static final int PICTURES_AT_INNER_CORNER = 3;
	private static final double RANDOM_MOVEMENT_THRESHOLD = 0.125;
	
	
	public ActingRobot(Vector3d position, String name, FileServer fileServer) {
		super(position, name, fileServer);
		foundWall = false;
		attachedDevices = new AttachedDevices(this);
		
        this.status = RobotStatus.FIND_WALL;
        FileServer.saveStatus(this.name, RobotStatus.FIND_WALL);
        failedCoordinateSaveCount=0;
        attemptsAtFindingWall=0;
        isFinished = false;
	}
	
    /** This method is called by the simulator engine on reset. */
    public void initBehavior() {
        System.out.println("I exist and my name is " + this.name);
        foundWall = false;
        traversedPoints = new CoordinateRow();  
        failedCoordinateSaveCount=0;
        attemptsAtFindingWall=0;
        isFinished = false;
    }

    /** This method is called cyclically (20 times per second) by the simulator engine. */
    public void performBehavior() {
        updateStatus();
        sendCurrentCoordinate();
        
    	if(this.status == RobotStatus.FIND_WALL || this.status == RobotStatus.COVER_WALL){
    		// This gets done every frame, to ensure that while the robot is moving along a wall, every single coordinate
    		// is stored and not just one coordinate every 20th of a frame
    		if(foundWall){
    			
    			// Keep track of how many times a save is 'rejected' because the point has already been saved
    			boolean val = this.sendWallCoordinate();
    			if(!val){
    				failedCoordinateSaveCount += 1;
    			}
    			
    			// If the number of rejections is bigger than 100 or a rover is in range, the rover should set itself to find a new wall
    			if(failedCoordinateSaveCount > FAILED_SAVE_COORDINATE_THRESHOLD || roverInRange()){
    				rotate(90);
    				
        			foundWall = false;
        			attemptsAtFindingWall=0;
    				this.setColor(GREEN_COLOR);

    			}
    		}
    		// This is done every 20th of a frame
	    	if(this.getCounter() % 20 == 0){
	    		out.println(getCurrentCoordinate());
	    		
				if(foundWall){
					checkBumperCollision();
	    			
	    			if(stuckAtCorner()){
	    				rotate(90);
	    				
	        			foundWall = false;
	        			attemptsAtFindingWall=0;
	    				this.setColor(GREEN_COLOR);

	    			}
	    			
	    			if(getRightSonarMeasurement() > 0.1){
	    				takePictureAtOuterCorner();
	    				sendCarbonDioxideReading(takeCarbonDioxideReading());
	    				rotate(-90);
	    			}
	    			
	    			if(robotFrontTooClose()){
	    				takePictureAtInnerCorner();
	    				sendCarbonDioxideReading(takeCarbonDioxideReading());
	        			rotate(90);
	    			}
	    			
	    		}else{
	    			checkBumperCollision();
	    			
	    			randomMovement();
	    			
	    			if(attemptsAtFindingWall > STOP_THRESHOLD){
	    				this.status = RobotStatus.FINISHED;
	    				FileServer.saveStatus(this.name, RobotStatus.FINISHED);
	    			}
	    			
	        		if(robotFrontTooClose() && !coveredWallPoint() && !roverInRange()){  
	        			rotate(90);
	        			
	    				foundWall = true;
	    				failedCoordinateSaveCount = 0;
	    				this.setColor(RED_COLOR);
	        		}else if(robotFrontTooClose()){
	        			rotate(180);
	        		}
	        		
		    		attemptsAtFindingWall += 1;
		    		
		    		
	    		}
	        	this.setTranslationalVelocity(1);
	    		saveCoordinate();
	    	}
    	}else if(this.status == RobotStatus.PAUSE){
    		this.setTranslationalVelocity(0);
    	}else if(this.status == RobotStatus.FINISHED){
    		if(!isFinished){
        		this.setTranslationalVelocity(0);
        		this.reset();
        		this.detach();
        		isFinished = true;
    		}
    	}
    }


    private void sendCurrentCoordinate() {
    	FileServer.saveRobotCurrentCoordinate(this.name, getCurrentCoordinate());
	}

	private boolean roverInRange() {
		HashMap<String, Coordinate> coordinates = FileServer.getRobotCurrentCoordinates();
		Set<String> keys = coordinates.keySet();
		
		for (Iterator<String> it = keys.iterator(); it.hasNext(); ) {
	        String f = it.next();
	        if (!f.equals(this.name)){
	            if(Coordinate.isInRange(coordinates.get(f), this.getCurrentCoordinate(), BOTS_RANGE_THRESHOLD)){
	            	return true;
	            }
	        }
	    }
		
		return false;
	}

	private boolean coveredWallPoint() {
		CoordinateRow wallCoordinates = FileServer.getWallCoordinates();

		for(int i=0; i < wallCoordinates.size(); i++){
			if(Coordinate.isInRange(wallCoordinates.get(i), this.getCurrentCoordinate(), 5)){
				return true;
			}
		}
		return false;
	}


	private void takePictureAtInnerCorner() {
		rotate(90);
		
		for(int i = 1; i <= PICTURES_AT_INNER_CORNER; i++){
	    	rotate((i / PICTURES_AT_INNER_CORNER) * 90);
	    	
	    	sendPicture(takePicture());
		}
		
    	rotate(-180);
	}
	
	private void takePictureAtOuterCorner() {
		for(int i = 0 ; i < 2; i++){
			sendPicture(takePicture());
			rotate(90);
		}

		sendPicture(takePicture());

    	rotate(-180);
	}

	private void randomMovement() {
		if(Math.random() < RANDOM_MOVEMENT_THRESHOLD)
			rotate(90);
		
	}

	/**
	 * In some situations the robot can be positioned in such a way that its front sonar thinks its way is clear,
	 * when in fact there is an object slightly to the left or right of the rover, which is undetectable by the sonar.
	 * For this we check the two bumpers directly to the right and directly to the left of the front sonar sensor,
	 * if these are activates we know that the robot must be stuck and therefore the process needs to be restarted. 
	 */
	public void checkBumperCollision() {
		if(frontBumperCollision()){
			foundWall = false;
			rotate(180);
		}
	}

	/**
	 * 
	 * @return 
	 */
	public boolean stuckAtCorner() {
		if(traversedPoints.size() < 3){
			return false;
		}
		
    	for(int i = 0; i < 3; i++){
    		Coordinate p1 = traversedPoints.get(i);
    		Coordinate p2 = traversedPoints.get(i + 1);
    		if(!p1.equals(p2)){
    			return false;
    		}else{
    		}
    	}
    	
		return true;
	}

	/**
	 * Check if bumper 1 or 11 (the two sensors right next to the front bumper sensor, which is sensor 0) detect a colliosion.
	 * @return 
	 * 
	 */
	public boolean frontBumperCollision() {
		return bumperSensor.getMeasurement(1) < BUMPER_THRESHOLD || bumperSensor.getMeasurement(11) < BUMPER_THRESHOLD;
	}


	/**
	 * 
	 */
	public void updateStatus() {
		HashMap<String, RobotStatus> statuses = FileServer.getStatuses();
		
		if(this.status != RobotStatus.COVER_WALL && statuses.values().contains(RobotStatus.COVER_WALL)){
			this.status = RobotStatus.PAUSE;
			FileServer.saveStatus(this.name, RobotStatus.PAUSE);
		}else if(this.status == RobotStatus.COVER_WALL && !statuses.values().contains(RobotStatus.COVER_WALL)){
			// Do nothing
		}else if(this.status == RobotStatus.COVER_WALL && foundWall == false){
			this.status = RobotStatus.FIND_WALL;
			FileServer.saveStatus(this.name, RobotStatus.FIND_WALL);
		}else if(this.status == RobotStatus.FIND_WALL && foundWall == true){
			this.status = RobotStatus.COVER_WALL;
			FileServer.saveStatus(this.name, RobotStatus.COVER_WALL);
		}else if(this.status == RobotStatus.PAUSE){
			this.status = RobotStatus.FIND_WALL;
		}
		
	}
	
	public BufferedImage takePicture(){
		return this.attachedDevices.getCamera().takePicture();
	}
	
	public void sendPicture(BufferedImage picture){
		FileServer.savePicture(picture);
	}
	
	public double takeCarbonDioxideReading(){
		return this.attachedDevices.getCarbonDioxideSensor().getReading();
	}
	
	public void sendCarbonDioxideReading(double reading){
		FileServer.saveCarbonDioxideReading(reading);
	}

	/**
	 * 
	 */
	public boolean sendWallCoordinate() {
		return FileServer.saveWallCoordinate(this.getCurrentCoordinate());
	}
	
};
